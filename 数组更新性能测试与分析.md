#### 更新 state 中的数组性能测试

#### push

- 有 key ， 无 key 性能相同

- 100 条以下：10ms 内完成
- 1000 条：50ms
- 10000 条：500ms
- 20000 条：2000 ms

结论：当向数组中 push 数据时，props.key 无法优化

#### splice，生成随机数组，随机 key 值，随机插入

- 插入 20000 条：有 key 700ms ~ 800ms；无 key：超过 2000ms 

结论：插入数据时，优化效果明显

#### 但在工程中没有人会用大数组存数据，每次更新量不会超过 100 ，此时 key 的优化效果就可以忽略了

<a href="https://juejin.im/post/5d455914518825262a6bc079#heading-3">详解 Diff 算法以及循环要加 key 值问题</a>

react & vue 进行 diff 的三个方法，通过这三个方法的循环执行，完成整个 diff 的过程

- tree diff：同层对比

- component diff：同组件对比，不同组件则为 dirty component，整个节点删掉重新构建；相同组件则递归这个节点

- element diff：同层列表对比

注意：当有三个相同类型的组件，不是通过循环的方式引用进来（正常不会有人这么做，这里只是特殊讨论一下），在 diff 时走的是 component diff，依次对比三个组件，只有循环出来的三个组件，才会走 element diff，判断是否需要节点复用

#### 节点复用

react 和 vue 都有 “就地复用” 的概念，且只有在循环列表时才会出现，体现如下：

在循环列表时，即使顺序打乱，也不会重新创建组件列表（列表中的每个节点都是相同类型的，也从另一方变迎合了 component diff，但与 component diff 有很大不同），而是使用老的节点，通过判断节点有无变化，来选择是否需要更新这个节点

那什么



