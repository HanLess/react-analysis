#### 更新 state 中的数组性能测试

#### push

- 有 key ， 无 key 性能相同

- 100 条以下：10ms 内完成
- 1000 条：50ms
- 10000 条：500ms
- 20000 条：2000 ms

结论：当向数组中 push 数据时，props.key 无法优化

#### splice，生成随机数组，随机 key 值，随机插入

- 插入 20000 条：有 key 700ms ~ 800ms；无 key：超过 2000ms 

结论：插入数据时，优化效果明显

#### 但在工程中没有人会用大数组存数据，每次更新量不会超过 100 ，此时 key 的优化效果就可以忽略了

## 原因分析

<a href="https://juejin.im/post/5d455914518825262a6bc079#heading-3">详解 Diff 算法以及循环要加 key 值问题</a>

react & vue 进行 diff 的三个方法，通过这三个方法的循环执行，完成整个 diff 的过程

- tree diff：同层对比

- component diff：同组件对比，不同组件则为 dirty component，整个节点删掉重新构建；相同组件则递归这个节点

- element diff：同层列表对比

注意：当有三个相同类型的组件，不是通过循环的方式引用进来（正常不会有人这么做，这里只是特殊讨论一下），在 diff 时走的是 component diff，依次对比三个组件，只有循环出来的三个组件，才会走 element diff，判断是否需要节点复用

#### 节点复用

react 和 vue 都有 “就地复用” 的概念，且只有在循环列表时才会出现，体现如下：

在循环列表时，即使顺序打乱，也不会重新创建组件列表（列表中的每个节点都是相同类型的，也从另一方变迎合了 component diff，但与 component diff 有很大不同），而是使用老的节点，通过判断节点有无变化，来选择是否需要更新这个节点

那什么时候有变化 —— 当 props 发生变化的时候，就会触发子组件的更新，否则不会；当就地复用的时候，组件内部的 state / data 也会被复用。

这就产生了这个经典的 bug

```
<template>
  <div id="app">
    <h1 @click="dele()">delete</h1>
    <h1 @click="change()">change</h1>
    <Kid v-for="item in list" />
  </div>
</template>
<script>
  import Kid from './components/Kid.vue'

  export default {
    components : {
      Kid
    },
    data() {
      return {
          list: [1,2,3]
      }
    },
    updated() {
      console.log('update run !')
    },
    methods: {
      change(){
        this.list = [10,2,3]
      },
      dele(){
        this.list.splice(1,1)
      }
    }
  }
</script>
```

删掉第二项，反而第三项消失了。原因如下：

删掉节点二，对于 vue/react 来说，其实是删掉了最后一个节点（节点三），因为 vue 不知道节点的顺序，只知道节点少了一个，当遍历到第二个节点时，发现：

节点类型相同，且没有发生更新（props 没有更新，data 也没有更新），则就地复用之前的第二个节点，则 data 没有变化，还展示了第二个节点内容。实际就删除了节

点三









